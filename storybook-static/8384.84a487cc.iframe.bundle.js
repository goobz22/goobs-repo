'use strict'
;(self.webpackChunkgoobs_frontend = self.webpackChunkgoobs_frontend || []).push(
  [
    [8384],
    {
      './node_modules/@mui/icons-material/esm/Delete.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z',
          }),
          'Delete'
        )
      },
      './node_modules/@mui/icons-material/esm/Download.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M5 20h14v-2H5zM19 9h-4V3H9v6H5l7 7z',
          }),
          'Download'
        )
      },
      './node_modules/@mui/icons-material/esm/Edit.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z',
          }),
          'Edit'
        )
      },
      './node_modules/@mui/icons-material/esm/FileCopy.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z',
          }),
          'FileCopy'
        )
      },
      './node_modules/@mui/icons-material/esm/Search.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14',
          }),
          'Search'
        )
      },
      './node_modules/@mui/icons-material/esm/Visibility.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3',
          }),
          'Visibility'
        )
      },
      './node_modules/@mui/icons-material/esm/VisibilityOff.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => __WEBPACK_DEFAULT_EXPORT__,
        })
        var _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/@mui/material/utils/createSvgIcon.js'
            ),
          react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const __WEBPACK_DEFAULT_EXPORT__ = (0,
        _utils_createSvgIcon_js__WEBPACK_IMPORTED_MODULE_1__.A)(
          (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)('path', {
            d: 'M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7M2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2m4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3z',
          }),
          'VisibilityOff'
        )
      },
      './node_modules/@mui/material/Checkbox/Checkbox.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => Checkbox_Checkbox,
        })
        var react = __webpack_require__(
            './node_modules/next/dist/compiled/react/index.js'
          ),
          clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
          composeClasses = __webpack_require__(
            './node_modules/@mui/utils/esm/composeClasses/composeClasses.js'
          ),
          colorManipulator = __webpack_require__(
            './node_modules/@mui/system/esm/colorManipulator/colorManipulator.js'
          ),
          SwitchBase = __webpack_require__(
            './node_modules/@mui/material/internal/SwitchBase.js'
          ),
          createSvgIcon = __webpack_require__(
            './node_modules/@mui/material/utils/createSvgIcon.js'
          ),
          jsx_runtime = __webpack_require__(
            './node_modules/next/dist/compiled/react/jsx-runtime.js'
          )
        const CheckBoxOutlineBlank = (0, createSvgIcon.A)(
            (0, jsx_runtime.jsx)('path', {
              d: 'M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z',
            }),
            'CheckBoxOutlineBlank'
          ),
          CheckBox = (0, createSvgIcon.A)(
            (0, jsx_runtime.jsx)('path', {
              d: 'M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z',
            }),
            'CheckBox'
          ),
          IndeterminateCheckBox = (0, createSvgIcon.A)(
            (0, jsx_runtime.jsx)('path', {
              d: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z',
            }),
            'IndeterminateCheckBox'
          )
        var capitalize = __webpack_require__(
            './node_modules/@mui/material/utils/capitalize.js'
          ),
          rootShouldForwardProp = __webpack_require__(
            './node_modules/@mui/material/styles/rootShouldForwardProp.js'
          ),
          generateUtilityClasses = __webpack_require__(
            './node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js'
          ),
          generateUtilityClass = __webpack_require__(
            './node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js'
          )
        function getCheckboxUtilityClass(slot) {
          return (0, generateUtilityClass.Ay)('MuiCheckbox', slot)
        }
        const Checkbox_checkboxClasses = (0, generateUtilityClasses.A)(
          'MuiCheckbox',
          [
            'root',
            'checked',
            'disabled',
            'indeterminate',
            'colorPrimary',
            'colorSecondary',
            'sizeSmall',
            'sizeMedium',
          ]
        )
        var styled = __webpack_require__(
            './node_modules/@mui/material/styles/styled.js'
          ),
          memoTheme = __webpack_require__(
            './node_modules/@mui/material/utils/memoTheme.js'
          ),
          createSimplePaletteValueFilter = __webpack_require__(
            './node_modules/@mui/material/utils/createSimplePaletteValueFilter.js'
          ),
          DefaultPropsProvider = __webpack_require__(
            './node_modules/@mui/material/DefaultPropsProvider/DefaultPropsProvider.js'
          )
        const CheckboxRoot = (0, styled.Ay)(SwitchBase.A, {
            shouldForwardProp: prop =>
              (0, rootShouldForwardProp.A)(prop) || 'classes' === prop,
            name: 'MuiCheckbox',
            slot: 'Root',
            overridesResolver: (props, styles) => {
              const { ownerState } = props
              return [
                styles.root,
                ownerState.indeterminate && styles.indeterminate,
                styles[`size${(0, capitalize.A)(ownerState.size)}`],
                'default' !== ownerState.color &&
                  styles[`color${(0, capitalize.A)(ownerState.color)}`],
              ]
            },
          })(
            (0, memoTheme.A)(({ theme }) => ({
              color: (theme.vars || theme).palette.text.secondary,
              variants: [
                {
                  props: { color: 'default', disableRipple: !1 },
                  style: {
                    '&:hover': {
                      backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
                        : (0, colorManipulator.X4)(
                            theme.palette.action.active,
                            theme.palette.action.hoverOpacity
                          ),
                    },
                  },
                },
                ...Object.entries(theme.palette)
                  .filter((0, createSimplePaletteValueFilter.A)())
                  .map(([color]) => ({
                    props: { color, disableRipple: !1 },
                    style: {
                      '&:hover': {
                        backgroundColor: theme.vars
                          ? `rgba(${theme.vars.palette[color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})`
                          : (0, colorManipulator.X4)(
                              theme.palette[color].main,
                              theme.palette.action.hoverOpacity
                            ),
                      },
                    },
                  })),
                ...Object.entries(theme.palette)
                  .filter((0, createSimplePaletteValueFilter.A)())
                  .map(([color]) => ({
                    props: { color },
                    style: {
                      [`&.${Checkbox_checkboxClasses.checked}, &.${Checkbox_checkboxClasses.indeterminate}`]:
                        { color: (theme.vars || theme).palette[color].main },
                      [`&.${Checkbox_checkboxClasses.disabled}`]: {
                        color: (theme.vars || theme).palette.action.disabled,
                      },
                    },
                  })),
                {
                  props: { disableRipple: !1 },
                  style: {
                    '&:hover': {
                      '@media (hover: none)': {
                        backgroundColor: 'transparent',
                      },
                    },
                  },
                },
              ],
            }))
          ),
          defaultCheckedIcon = (0, jsx_runtime.jsx)(CheckBox, {}),
          defaultIcon = (0, jsx_runtime.jsx)(CheckBoxOutlineBlank, {}),
          defaultIndeterminateIcon = (0, jsx_runtime.jsx)(
            IndeterminateCheckBox,
            {}
          ),
          Checkbox_Checkbox = react.forwardRef(function Checkbox(inProps, ref) {
            const props = (0, DefaultPropsProvider.b)({
                props: inProps,
                name: 'MuiCheckbox',
              }),
              {
                checkedIcon = defaultCheckedIcon,
                color = 'primary',
                icon: iconProp = defaultIcon,
                indeterminate = !1,
                indeterminateIcon:
                  indeterminateIconProp = defaultIndeterminateIcon,
                inputProps,
                size = 'medium',
                disableRipple = !1,
                className,
                ...other
              } = props,
              icon = indeterminate ? indeterminateIconProp : iconProp,
              indeterminateIcon = indeterminate
                ? indeterminateIconProp
                : checkedIcon,
              ownerState = {
                ...props,
                disableRipple,
                color,
                indeterminate,
                size,
              },
              classes = (ownerState => {
                const { classes, indeterminate, color, size } = ownerState,
                  slots = {
                    root: [
                      'root',
                      indeterminate && 'indeterminate',
                      `color${(0, capitalize.A)(color)}`,
                      `size${(0, capitalize.A)(size)}`,
                    ],
                  },
                  composedClasses = (0, composeClasses.A)(
                    slots,
                    getCheckboxUtilityClass,
                    classes
                  )
                return { ...classes, ...composedClasses }
              })(ownerState)
            return (0, jsx_runtime.jsx)(CheckboxRoot, {
              type: 'checkbox',
              inputProps: {
                'data-indeterminate': indeterminate,
                ...inputProps,
              },
              icon: react.cloneElement(icon, {
                fontSize: icon.props.fontSize ?? size,
              }),
              checkedIcon: react.cloneElement(indeterminateIcon, {
                fontSize: indeterminateIcon.props.fontSize ?? size,
              }),
              ownerState,
              ref,
              className: (0, clsx.A)(classes.root, className),
              disableRipple,
              ...other,
              classes,
            })
          })
      },
      './node_modules/@mui/material/internal/SwitchBase.js': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          A: () => internal_SwitchBase,
        })
        var react = __webpack_require__(
            './node_modules/next/dist/compiled/react/index.js'
          ),
          clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
          composeClasses = __webpack_require__(
            './node_modules/@mui/utils/esm/composeClasses/composeClasses.js'
          ),
          capitalize = __webpack_require__(
            './node_modules/@mui/material/utils/capitalize.js'
          ),
          rootShouldForwardProp = __webpack_require__(
            './node_modules/@mui/material/styles/rootShouldForwardProp.js'
          ),
          styled = __webpack_require__(
            './node_modules/@mui/material/styles/styled.js'
          ),
          useControlled = __webpack_require__(
            './node_modules/@mui/material/utils/useControlled.js'
          ),
          useFormControl = __webpack_require__(
            './node_modules/@mui/material/FormControl/useFormControl.js'
          ),
          ButtonBase = __webpack_require__(
            './node_modules/@mui/material/ButtonBase/ButtonBase.js'
          ),
          generateUtilityClasses = __webpack_require__(
            './node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js'
          ),
          generateUtilityClass = __webpack_require__(
            './node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js'
          )
        function getSwitchBaseUtilityClass(slot) {
          return (0, generateUtilityClass.Ay)('PrivateSwitchBase', slot)
        }
        ;(0, generateUtilityClasses.A)('PrivateSwitchBase', [
          'root',
          'checked',
          'disabled',
          'input',
          'edgeStart',
          'edgeEnd',
        ])
        var jsx_runtime = __webpack_require__(
          './node_modules/next/dist/compiled/react/jsx-runtime.js'
        )
        const SwitchBaseRoot = (0, styled.Ay)(ButtonBase.A)({
            padding: 9,
            borderRadius: '50%',
            variants: [
              {
                props: { edge: 'start', size: 'small' },
                style: { marginLeft: -3 },
              },
              {
                props: ({ edge, ownerState }) =>
                  'start' === edge && 'small' !== ownerState.size,
                style: { marginLeft: -12 },
              },
              {
                props: { edge: 'end', size: 'small' },
                style: { marginRight: -3 },
              },
              {
                props: ({ edge, ownerState }) =>
                  'end' === edge && 'small' !== ownerState.size,
                style: { marginRight: -12 },
              },
            ],
          }),
          SwitchBaseInput = (0, styled.Ay)('input', {
            shouldForwardProp: rootShouldForwardProp.A,
          })({
            cursor: 'inherit',
            position: 'absolute',
            opacity: 0,
            width: '100%',
            height: '100%',
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            zIndex: 1,
          }),
          internal_SwitchBase = react.forwardRef(
            function SwitchBase(props, ref) {
              const {
                  autoFocus,
                  checked: checkedProp,
                  checkedIcon,
                  className,
                  defaultChecked,
                  disabled: disabledProp,
                  disableFocusRipple = !1,
                  edge = !1,
                  icon,
                  id,
                  inputProps,
                  inputRef,
                  name,
                  onBlur,
                  onChange,
                  onFocus,
                  readOnly,
                  required = !1,
                  tabIndex,
                  type,
                  value,
                  ...other
                } = props,
                [checked, setCheckedState] = (0, useControlled.A)({
                  controlled: checkedProp,
                  default: Boolean(defaultChecked),
                  name: 'SwitchBase',
                  state: 'checked',
                }),
                muiFormControl = (0, useFormControl.A)()
              let disabled = disabledProp
              muiFormControl &&
                void 0 === disabled &&
                (disabled = muiFormControl.disabled)
              const hasLabelFor = 'checkbox' === type || 'radio' === type,
                ownerState = {
                  ...props,
                  checked,
                  disabled,
                  disableFocusRipple,
                  edge,
                },
                classes = (ownerState => {
                  const { classes, checked, disabled, edge } = ownerState,
                    slots = {
                      root: [
                        'root',
                        checked && 'checked',
                        disabled && 'disabled',
                        edge && `edge${(0, capitalize.A)(edge)}`,
                      ],
                      input: ['input'],
                    }
                  return (0, composeClasses.A)(
                    slots,
                    getSwitchBaseUtilityClass,
                    classes
                  )
                })(ownerState)
              return (0, jsx_runtime.jsxs)(SwitchBaseRoot, {
                component: 'span',
                className: (0, clsx.A)(classes.root, className),
                centerRipple: !0,
                focusRipple: !disableFocusRipple,
                disabled,
                tabIndex: null,
                role: void 0,
                onFocus: event => {
                  onFocus && onFocus(event),
                    muiFormControl &&
                      muiFormControl.onFocus &&
                      muiFormControl.onFocus(event)
                },
                onBlur: event => {
                  onBlur && onBlur(event),
                    muiFormControl &&
                      muiFormControl.onBlur &&
                      muiFormControl.onBlur(event)
                },
                ownerState,
                ref,
                ...other,
                children: [
                  (0, jsx_runtime.jsx)(SwitchBaseInput, {
                    autoFocus,
                    checked: checkedProp,
                    defaultChecked,
                    className: classes.input,
                    disabled,
                    id: hasLabelFor ? id : void 0,
                    name,
                    onChange: event => {
                      if (event.nativeEvent.defaultPrevented) return
                      const newChecked = event.target.checked
                      setCheckedState(newChecked),
                        onChange && onChange(event, newChecked)
                    },
                    readOnly,
                    ref: inputRef,
                    required,
                    ownerState,
                    tabIndex,
                    type,
                    ...('checkbox' === type && void 0 === value
                      ? {}
                      : { value }),
                    ...inputProps,
                  }),
                  checked ? checkedIcon : icon,
                ],
              })
            }
          )
      },
      './node_modules/jotai/esm/react.mjs': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          Xr: () => useSetAtom,
          fp: () => useAtom,
          md: () => useAtomValue,
        })
        var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            './node_modules/next/dist/compiled/react/index.js'
          ),
          jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            './node_modules/jotai/esm/vanilla.mjs'
          )
        const StoreContext = (0,
          react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0),
          useStore = options => {
            const store = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              StoreContext
            )
            return (
              (null == options ? void 0 : options.store) ||
              store ||
              (0, jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.zp)()
            )
          },
          isPromiseLike = x =>
            'function' == typeof (null == x ? void 0 : x.then),
          attachPromiseMeta = promise => {
            ;(promise.status = 'pending'),
              promise.then(
                v => {
                  ;(promise.status = 'fulfilled'), (promise.value = v)
                },
                e => {
                  ;(promise.status = 'rejected'), (promise.reason = e)
                }
              )
          },
          use =
            react__WEBPACK_IMPORTED_MODULE_0__.use ||
            (promise => {
              if ('pending' === promise.status) throw promise
              if ('fulfilled' === promise.status) return promise.value
              throw 'rejected' === promise.status
                ? promise.reason
                : (attachPromiseMeta(promise), promise)
            }),
          continuablePromiseMap = new WeakMap(),
          createContinuablePromise = promise => {
            let continuablePromise = continuablePromiseMap.get(promise)
            return (
              continuablePromise ||
                ((continuablePromise = new Promise((resolve, reject) => {
                  let curr = promise
                  const onFulfilled = me => v => {
                      curr === me && resolve(v)
                    },
                    onRejected = me => e => {
                      curr === me && reject(e)
                    },
                    registerCancelHandler = p => {
                      'onCancel' in p &&
                        'function' == typeof p.onCancel &&
                        p.onCancel(nextValue => {
                          if (nextValue === p)
                            throw new Error(
                              '[Bug] p is not updated even after cancelation'
                            )
                          isPromiseLike(nextValue)
                            ? (continuablePromiseMap.set(
                                nextValue,
                                continuablePromise
                              ),
                              (curr = nextValue),
                              nextValue.then(
                                onFulfilled(nextValue),
                                onRejected(nextValue)
                              ),
                              registerCancelHandler(nextValue))
                            : resolve(nextValue)
                        })
                    }
                  promise.then(onFulfilled(promise), onRejected(promise)),
                    registerCancelHandler(promise)
                })),
                continuablePromiseMap.set(promise, continuablePromise)),
              continuablePromise
            )
          }
        function useAtomValue(atom, options) {
          const store = useStore(options),
            [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] =
              (0, react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(
                prev => {
                  const nextValue = store.get(atom)
                  return Object.is(prev[0], nextValue) &&
                    prev[1] === store &&
                    prev[2] === atom
                    ? prev
                    : [nextValue, store, atom]
                },
                void 0,
                () => [store.get(atom), store, atom]
              )
          let value = valueFromReducer
          ;(storeFromReducer === store && atomFromReducer === atom) ||
            (rerender(), (value = store.get(atom)))
          const delay = null == options ? void 0 : options.delay
          if (
            ((0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
              const unsub = store.sub(atom, () => {
                if ('number' == typeof delay) {
                  const value2 = store.get(atom)
                  return (
                    isPromiseLike(value2) &&
                      attachPromiseMeta(createContinuablePromise(value2)),
                    void setTimeout(rerender, delay)
                  )
                }
                rerender()
              })
              return rerender(), unsub
            }, [store, atom, delay]),
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value),
            isPromiseLike(value))
          ) {
            const promise = createContinuablePromise(value)
            return use(promise)
          }
          return value
        }
        function useSetAtom(atom, options) {
          const store = useStore(options)
          return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
            (...args) => {
              if (!('write' in atom)) throw new Error('not writable atom')
              return store.set(atom, ...args)
            },
            [store, atom]
          )
        }
        function useAtom(atom, options) {
          return [useAtomValue(atom, options), useSetAtom(atom, options)]
        }
      },
      './node_modules/jotai/esm/vanilla.mjs': (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.d(__webpack_exports__, {
          eU: () => atom,
          zp: () => getDefaultStore,
        })
        var console = __webpack_require__(
          './node_modules/console-browserify/index.js'
        )
        let keyCount = 0
        function atom(read, write) {
          const key = 'atom' + ++keyCount,
            config = {
              toString() {
                return this.debugLabel ? key + ':' + this.debugLabel : key
              },
            }
          return (
            'function' == typeof read
              ? (config.read = read)
              : ((config.init = read),
                (config.read = defaultRead),
                (config.write = defaultWrite)),
            write && (config.write = write),
            config
          )
        }
        function defaultRead(get) {
          return get(this)
        }
        function defaultWrite(get, set, arg) {
          return set(this, 'function' == typeof arg ? arg(get(this)) : arg)
        }
        const isSelfAtom = (atom, a) =>
            atom.unstable_is ? atom.unstable_is(a) : a === atom,
          hasInitialValue = atom => 'init' in atom,
          isActuallyWritableAtom = atom => !!atom.write,
          cancelablePromiseMap = new WeakMap(),
          isPendingPromise = value => {
            var _a
            return (
              isPromiseLike(value) &&
              !(null == (_a = cancelablePromiseMap.get(value)) ? void 0 : _a[1])
            )
          },
          isPromiseLike = p =>
            'function' == typeof (null == p ? void 0 : p.then),
          isAtomStateInitialized = atomState =>
            'v' in atomState || 'e' in atomState,
          returnAtomValue = atomState => {
            if ('e' in atomState) throw atomState.e
            if (!('v' in atomState))
              throw new Error('[Bug] atom state is not initialized')
            return atomState.v
          },
          addPendingPromiseToDependency = (
            atom,
            promise,
            dependencyAtomState
          ) => {
            dependencyAtomState.p.has(atom) ||
              (dependencyAtomState.p.add(atom),
              promise.then(
                () => {
                  dependencyAtomState.p.delete(atom)
                },
                () => {
                  dependencyAtomState.p.delete(atom)
                }
              ))
          },
          INTERNAL_flushStoreHook = Symbol.for(
            'JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK'
          ),
          buildStore = (...storeArgs) => {
            const [
                getAtomState,
                setAtomState,
                atomRead,
                atomWrite,
                atomOnInit,
                atomOnMount,
              ] = storeArgs,
              ensureAtomState = atom => {
                if (!atom) throw new Error('Atom is undefined or null')
                let atomState = getAtomState(atom)
                return (
                  atomState ||
                    ((atomState = { d: new Map(), p: new Set(), n: 0 }),
                    setAtomState(atom, atomState),
                    null == atomOnInit || atomOnInit(atom, store)),
                  atomState
                )
              },
              invalidatedAtoms = new WeakMap(),
              changedAtoms = new Map(),
              unmountCallbacks = new Set(),
              mountCallbacks = new Set(),
              flushCallbacks = () => {
                var _a
                const errors = [],
                  call = fn => {
                    try {
                      fn()
                    } catch (e) {
                      errors.push(e)
                    }
                  }
                do {
                  null == (_a = store[INTERNAL_flushStoreHook]) ||
                    _a.call(store)
                  const callbacks = new Set(),
                    add = callbacks.add.bind(callbacks)
                  changedAtoms.forEach(atomState => {
                    var _a2
                    return null == (_a2 = atomState.m)
                      ? void 0
                      : _a2.l.forEach(add)
                  }),
                    changedAtoms.clear(),
                    unmountCallbacks.forEach(add),
                    unmountCallbacks.clear(),
                    mountCallbacks.forEach(add),
                    mountCallbacks.clear(),
                    callbacks.forEach(call),
                    changedAtoms.size && recomputeInvalidatedAtoms()
                } while (
                  changedAtoms.size ||
                  unmountCallbacks.size ||
                  mountCallbacks.size
                )
                if (errors.length) throw errors[0]
              },
              setAtomStateValueOrPromise = (
                atom,
                atomState,
                valueOrPromise
              ) => {
                const hasPrevValue = 'v' in atomState,
                  prevValue = atomState.v,
                  pendingPromise = isPendingPromise(atomState.v)
                    ? atomState.v
                    : null
                if (isPromiseLike(valueOrPromise)) {
                  ;(promise => {
                    if (cancelablePromiseMap.has(promise)) return
                    const promiseState = [new Set(), !1]
                    cancelablePromiseMap.set(promise, promiseState)
                    const settle = () => {
                      promiseState[1] = !0
                    }
                    promise.then(settle, settle),
                      (promise.onCancel = fn => {
                        promiseState[0].add(fn)
                      })
                  })(valueOrPromise)
                  for (const a of atomState.d.keys())
                    addPendingPromiseToDependency(
                      atom,
                      valueOrPromise,
                      ensureAtomState(a)
                    )
                  atomState.v = valueOrPromise
                } else atomState.v = valueOrPromise
                delete atomState.e,
                  (hasPrevValue && Object.is(prevValue, atomState.v)) ||
                    (++atomState.n,
                    pendingPromise &&
                      ((promise, nextValue) => {
                        const promiseState = cancelablePromiseMap.get(promise)
                        if (!promiseState)
                          throw new Error('[Bug] cancelable promise not found')
                        ;(promiseState[1] = !0),
                          promiseState[0].forEach(fn => fn(nextValue))
                      })(pendingPromise, valueOrPromise))
              },
              readAtomState = atom => {
                var _a
                const atomState = ensureAtomState(atom)
                if (isAtomStateInitialized(atomState)) {
                  if (atomState.m && invalidatedAtoms.get(atom) !== atomState.n)
                    return atomState
                  if (
                    Array.from(atomState.d).every(
                      ([a, n]) => readAtomState(a).n === n
                    )
                  )
                    return atomState
                }
                atomState.d.clear()
                let isSync = !0
                const mountDependenciesIfAsync = () => {
                    atomState.m &&
                      (mountDependencies(atom, atomState),
                      recomputeInvalidatedAtoms(),
                      flushCallbacks())
                  },
                  getter = a => {
                    if (isSelfAtom(atom, a)) {
                      const aState2 = ensureAtomState(a)
                      if (!isAtomStateInitialized(aState2)) {
                        if (!hasInitialValue(a)) throw new Error('no atom init')
                        setAtomStateValueOrPromise(a, aState2, a.init)
                      }
                      return returnAtomValue(aState2)
                    }
                    const aState = readAtomState(a)
                    try {
                      return returnAtomValue(aState)
                    } finally {
                      ;((atom, atomState, a, aState) => {
                        var _a
                        if (a === atom)
                          throw new Error('[Bug] atom cannot depend on itself')
                        atomState.d.set(a, aState.n),
                          isPendingPromise(atomState.v) &&
                            addPendingPromiseToDependency(
                              atom,
                              atomState.v,
                              aState
                            ),
                          null == (_a = aState.m) || _a.t.add(atom)
                      })(atom, atomState, a, aState),
                        isSync || mountDependenciesIfAsync()
                    }
                  }
                let controller, setSelf
                const options = {
                  get signal() {
                    return (
                      controller || (controller = new AbortController()),
                      controller.signal
                    )
                  },
                  get setSelf() {
                    return (
                      isActuallyWritableAtom(atom) ||
                        console.warn(
                          'setSelf function cannot be used with read-only atom'
                        ),
                      !setSelf &&
                        isActuallyWritableAtom(atom) &&
                        (setSelf = (...args) => {
                          if (
                            (isSync &&
                              console.warn(
                                'setSelf function cannot be called in sync'
                              ),
                            !isSync)
                          )
                            return writeAtom(atom, ...args)
                        }),
                      setSelf
                    )
                  },
                }
                try {
                  const valueOrPromise = atomRead(atom, getter, options)
                  return (
                    setAtomStateValueOrPromise(atom, atomState, valueOrPromise),
                    isPromiseLike(valueOrPromise) &&
                      (null == (_a = valueOrPromise.onCancel) ||
                        _a.call(valueOrPromise, () =>
                          null == controller ? void 0 : controller.abort()
                        ),
                      valueOrPromise.then(
                        mountDependenciesIfAsync,
                        mountDependenciesIfAsync
                      )),
                    atomState
                  )
                } catch (error) {
                  return (
                    delete atomState.v,
                    (atomState.e = error),
                    ++atomState.n,
                    atomState
                  )
                } finally {
                  isSync = !1
                }
              },
              getMountedOrPendingDependents = atomState => {
                var _a
                const dependents = new Map()
                for (const a of (null == (_a = atomState.m) ? void 0 : _a.t) ||
                  []) {
                  const aState = ensureAtomState(a)
                  aState.m && dependents.set(a, aState)
                }
                for (const atomWithPendingPromise of atomState.p)
                  dependents.set(
                    atomWithPendingPromise,
                    ensureAtomState(atomWithPendingPromise)
                  )
                return dependents
              },
              invalidateDependents = atomState => {
                const stack = [atomState]
                for (; stack.length; ) {
                  const aState = stack.pop()
                  for (const [d, s] of getMountedOrPendingDependents(aState))
                    invalidatedAtoms.has(d) ||
                      (invalidatedAtoms.set(d, s.n), stack.push(s))
                }
              },
              recomputeInvalidatedAtoms = () => {
                var _a
                const topSortedReversed = [],
                  visiting = new WeakSet(),
                  visited = new WeakSet(),
                  stack = Array.from(changedAtoms)
                for (; stack.length; ) {
                  const [a, aState] = stack[stack.length - 1]
                  if (visited.has(a)) stack.pop()
                  else if (visiting.has(a))
                    invalidatedAtoms.get(a) === aState.n
                      ? topSortedReversed.push([a, aState, aState.n])
                      : (invalidatedAtoms.delete(a),
                        changedAtoms.set(a, aState)),
                      visited.add(a),
                      stack.pop()
                  else {
                    visiting.add(a)
                    for (const [d, s] of getMountedOrPendingDependents(aState))
                      visiting.has(d) || stack.push([d, s])
                  }
                }
                for (let i = topSortedReversed.length - 1; i >= 0; --i) {
                  const [a, aState, prevEpochNumber] = topSortedReversed[i]
                  let hasChangedDeps = !1
                  for (const dep of aState.d.keys())
                    if (dep !== a && changedAtoms.has(dep)) {
                      hasChangedDeps = !0
                      break
                    }
                  hasChangedDeps &&
                    (readAtomState(a),
                    mountDependencies(a, aState),
                    prevEpochNumber !== aState.n &&
                      (changedAtoms.set(a, aState),
                      null == (_a = aState.u) || _a.call(aState))),
                    invalidatedAtoms.delete(a)
                }
              },
              writeAtomState = (atom, ...args) => {
                let isSync = !0
                const getter = a => returnAtomValue(readAtomState(a)),
                  setter = (a, ...args2) => {
                    var _a
                    const aState = ensureAtomState(a)
                    try {
                      if (isSelfAtom(atom, a)) {
                        if (!hasInitialValue(a))
                          throw new Error('atom not writable')
                        const prevEpochNumber = aState.n,
                          v = args2[0]
                        return (
                          setAtomStateValueOrPromise(a, aState, v),
                          mountDependencies(a, aState),
                          void (
                            prevEpochNumber !== aState.n &&
                            (changedAtoms.set(a, aState),
                            null == (_a = aState.u) || _a.call(aState),
                            invalidateDependents(aState))
                          )
                        )
                      }
                      return writeAtomState(a, ...args2)
                    } finally {
                      isSync || (recomputeInvalidatedAtoms(), flushCallbacks())
                    }
                  }
                try {
                  return atomWrite(atom, getter, setter, ...args)
                } finally {
                  isSync = !1
                }
              },
              writeAtom = (atom, ...args) => {
                try {
                  return writeAtomState(atom, ...args)
                } finally {
                  recomputeInvalidatedAtoms(), flushCallbacks()
                }
              },
              mountDependencies = (atom, atomState) => {
                var _a
                if (atomState.m && !isPendingPromise(atomState.v)) {
                  for (const [a, n] of atomState.d)
                    if (!atomState.m.d.has(a)) {
                      const aState = ensureAtomState(a)
                      mountAtom(a, aState).t.add(atom),
                        atomState.m.d.add(a),
                        n !== aState.n &&
                          (changedAtoms.set(a, aState),
                          null == (_a = aState.u) || _a.call(aState),
                          invalidateDependents(aState))
                    }
                  for (const a of atomState.m.d || [])
                    if (!atomState.d.has(a)) {
                      atomState.m.d.delete(a)
                      const aMounted = unmountAtom(a, ensureAtomState(a))
                      null == aMounted || aMounted.t.delete(atom)
                    }
                }
              },
              mountAtom = (atom, atomState) => {
                var _a
                if (!atomState.m) {
                  readAtomState(atom)
                  for (const a of atomState.d.keys()) {
                    mountAtom(a, ensureAtomState(a)).t.add(atom)
                  }
                  if (
                    ((atomState.m = {
                      l: new Set(),
                      d: new Set(atomState.d.keys()),
                      t: new Set(),
                    }),
                    null == (_a = atomState.h) || _a.call(atomState),
                    isActuallyWritableAtom(atom))
                  ) {
                    const mounted = atomState.m,
                      processOnMount = () => {
                        let isSync = !0
                        const setAtom = (...args) => {
                          try {
                            return writeAtomState(atom, ...args)
                          } finally {
                            isSync ||
                              (recomputeInvalidatedAtoms(), flushCallbacks())
                          }
                        }
                        try {
                          const onUnmount = atomOnMount(atom, setAtom)
                          onUnmount &&
                            (mounted.u = () => {
                              isSync = !0
                              try {
                                onUnmount()
                              } finally {
                                isSync = !1
                              }
                            })
                        } finally {
                          isSync = !1
                        }
                      }
                    mountCallbacks.add(processOnMount)
                  }
                }
                return atomState.m
              },
              unmountAtom = (atom, atomState) => {
                var _a
                if (
                  !atomState.m ||
                  atomState.m.l.size ||
                  Array.from(atomState.m.t).some(a => {
                    var _a2
                    return null == (_a2 = ensureAtomState(a).m)
                      ? void 0
                      : _a2.d.has(atom)
                  })
                )
                  return atomState.m
                {
                  const onUnmount = atomState.m.u
                  onUnmount && unmountCallbacks.add(onUnmount),
                    delete atomState.m,
                    null == (_a = atomState.h) || _a.call(atomState)
                  for (const a of atomState.d.keys()) {
                    const aMounted = unmountAtom(a, ensureAtomState(a))
                    null == aMounted || aMounted.t.delete(atom)
                  }
                }
              },
              store = {
                get: atom => returnAtomValue(readAtomState(atom)),
                set: writeAtom,
                sub: (atom, listener) => {
                  const atomState = ensureAtomState(atom),
                    listeners = mountAtom(atom, atomState).l
                  return (
                    listeners.add(listener),
                    flushCallbacks(),
                    () => {
                      listeners.delete(listener),
                        unmountAtom(atom, atomState),
                        flushCallbacks()
                    }
                  )
                },
                unstable_derive: fn => buildStore(...fn(...storeArgs)),
              }
            return store
          },
          createStore = () => {
            const atomStateMap = new WeakMap(),
              store = buildStore(
                atom => atomStateMap.get(atom),
                (atom, atomState) =>
                  atomStateMap.set(atom, atomState).get(atom),
                (atom, ...params) => atom.read(...params),
                (atom, ...params) => atom.write(...params),
                (atom, ...params) => {
                  var _a
                  return null == (_a = atom.unstable_onInit)
                    ? void 0
                    : _a.call(atom, ...params)
                },
                (atom, ...params) => {
                  var _a
                  return null == (_a = atom.onMount)
                    ? void 0
                    : _a.call(atom, ...params)
                }
              )
            return (store => {
              const debugMountedAtoms = new Set()
              let savedGetAtomState,
                inRestoreAtom = 0
              const derivedStore = store.unstable_derive((...storeArgs) => {
                  const [getAtomState, setAtomState, , atomWrite] = storeArgs
                  return (
                    (savedGetAtomState = getAtomState),
                    (storeArgs[1] = function devSetAtomState(atom, atomState) {
                      setAtomState(atom, atomState)
                      const originalMounted = atomState.h
                      atomState.h = () => {
                        null == originalMounted || originalMounted(),
                          atomState.m
                            ? debugMountedAtoms.add(atom)
                            : debugMountedAtoms.delete(atom)
                      }
                    }),
                    (storeArgs[3] = function devAtomWrite(
                      atom,
                      getter,
                      setter,
                      ...args
                    ) {
                      return inRestoreAtom
                        ? setter(atom, ...args)
                        : atomWrite(atom, getter, setter, ...args)
                    }),
                    storeArgs
                  )
                }),
                savedStoreSet = derivedStore.set,
                devStore = {
                  dev4_get_internal_weak_map: () => ({
                    get: atom => {
                      const atomState = savedGetAtomState(atom)
                      if (atomState && 0 !== atomState.n) return atomState
                    },
                  }),
                  dev4_get_mounted_atoms: () => debugMountedAtoms,
                  dev4_restore_atoms: values => {
                    const restoreAtom = {
                      read: () => null,
                      write: (_get, set) => {
                        ++inRestoreAtom
                        try {
                          for (const [atom, value] of values)
                            hasInitialValue(atom) && set(atom, value)
                        } finally {
                          --inRestoreAtom
                        }
                      },
                    }
                    savedStoreSet(restoreAtom)
                  },
                }
              return Object.assign(derivedStore, devStore)
            })(store)
          }
        let defaultStore
        const getDefaultStore = () => (
          defaultStore ||
            ((defaultStore = createStore()),
            globalThis.__JOTAI_DEFAULT_STORE__ ||
              (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore),
            globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore &&
              console.warn(
                'Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044'
              )),
          defaultStore
        )
      },
    },
  ]
)
